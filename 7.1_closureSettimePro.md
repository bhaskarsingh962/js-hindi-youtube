## This is one of the classic closure + setTimeout + var vs let interview problems in JavaScript.

Letâ€™s break it down step by step with example ðŸ‘‡

Example with var:
for (var i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}


ðŸ‘‰ Expected:

1  
2  
3  
4  
5  


ðŸ‘‰ Actual output after running:

6  
6  
6  
6  
6

# Why does this happen? ðŸ¤”

var has function scope, not block scope.

So there is only one i variable shared across all iterations of the loop.

By the time the setTimeout callback runs (after 1 sec, 2 sec, â€¦), the loop is already finished, and i = 6.

Each closure points to the same reference of i, not a copy.

Example with let:
for (let i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}


ðŸ‘‰ Output:

1  
2  
3  
4  
5

## Why does let work? âœ…

# let has block scope.
# Each iteration of the loop creates a new i variable, separate from the others.
# The closure inside setTimeout keeps a reference to that unique i.
# So when the callback runs, it "remembers" the correct value for that iteration.

## Fixing var with Closure (Manual Way)

Before ES6 let, developers used an IIFE (Immediately Invoked Function Expression) to capture the value of i:

for (var i = 1; i <= 5; i++) {
  (function(x) {
    setTimeout(() => {
      console.log(x);
    }, x * 1000);
  })(i);
}


ðŸ‘‰ Output:

1  
2  
3  
4  
5


## Hereâ€™s why it works:

The IIFE creates a new scope for each i.

The current value i is passed as x, so the closure remembers x instead of the shared i.


# âœ… In short:

var causes all timeouts to share the same i â†’ wrong output.

let creates a fresh i per loop iteration â†’ correct output.

Closures + IIFE can also solve this with var.





## how set timeout runnnig 5 times Letâ€™s break it down carefully:

Code again:
for (var i = 1; i <= 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}

## What happens step by step:

## Loop execution (synchronous)

## The for loop runs immediately (not waiting for setTimeout).

## Iterations:

Iteration 1: schedules a setTimeout to run after 1000ms.
Iteration 2: schedules another to run after 2000ms.
Iteration 3: schedules another to run after 3000ms.
Iteration 4: schedules another to run after 4000ms.
Iteration 5: schedules another to run after 5000ms.

So total 5 setTimeout calls are scheduled.

Loop ends

## After finishing, i = 6 because loop condition fails (i <= 5 is false when i = 6).

## Timeout callbacks (asynchronous)

After 1s, first callback runs â†’ logs i (but i is already 6).
After 2s, second callback runs â†’ logs 6.
And so onâ€¦
ðŸ‘‰ Thatâ€™s why output is:

6
6
6
6
6


## Because the loop ran 5 iterations (i = 1 to 5), so setTimeout was called 5 times.
Each call registers a callback in the event queue to execute later.

Even though all log the same i, the number of callbacks scheduled is still 5.

Quick check with console.log inside loop:
for (var i = 1; i <= 5; i++) {
  console.log("Scheduling timeout for i =", i);
  setTimeout(() => console.log("Inside timeout:", i), i * 1000);
}


ðŸ‘‰ Output (synchronous part first):

Scheduling timeout for i = 1
Scheduling timeout for i = 2
Scheduling timeout for i = 3
Scheduling timeout for i = 4
Scheduling timeout for i = 5


ðŸ‘‰ Then after delays:

Inside timeout: 6
Inside timeout: 6
Inside timeout: 6
Inside timeout: 6
Inside timeout: 6


âœ… Answer in one line:
The loop calls setTimeout 5 times (one per iteration), so it runs only 5 callbacks. They all print 6 because closures with var share the same i.