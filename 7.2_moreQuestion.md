## ğŸ§  Closures â€” Deep Dive with Real Interview Concepts
ğŸ·ï¸ 1. What is a Closure?

A closure is formed when an inner function â€œremembersâ€ variables from its outer function even after the outer function has finished executing.

function outer() {
  let count = 0; // variable inside outer function
  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2
counter(); // 3


âœ… Explanation:

The outer() function runs once and returns inner.

Even though outer() has finished, inner still remembers count â€” thatâ€™s a closure.

## ğŸ•µï¸ 2. Data Hiding Using Closures

# Closures allow private variables â€” values that cannot be accessed directly from outside but can be modified through public methods.

function createBankAccount(initialBalance) {
  let balance = initialBalance; // private variable

  return {
    deposit: function(amount) {
      balance += amount;
      console.log(`Deposited: â‚¹${amount}`);
    },
    getBalance: function() {
      return `Your balance is â‚¹${balance}`;
    }
  };
}

const account = createBankAccount(1000);
account.deposit(500);
console.log(account.getBalance()); // Your balance is â‚¹1500
console.log(account.balance); // âŒ undefined (data hidden)


âœ… Why it matters:

Protects data from being directly modified.

Achieves encapsulation like in object-oriented programming.

## ğŸ§± 3. Constructor Function with Closures

You can also use closures inside constructor functions to hide private data for each object instance.

function Person(name, age) {
  let _age = age; // private variable

  this.getDetails = function() {
    return `${name} is ${_age} years old.`;
  };

  this.haveBirthday = function() {
    _age++;
  };
}

const person1 = new Person("Bhaskar", 21);
console.log(person1.getDetails()); // Bhaskar is 21 years old.
person1.haveBirthday();
console.log(person1.getDetails()); // Bhaskar is 22 years old.
console.log(person1._age); // âŒ undefined


âœ… Benefit:
Each instance gets its own closure, keeping _age private.

ğŸŒŸ 4. Importance of Closures (Interview Points)
Use Case	Description
Data Hiding	Prevents direct access to variables (like private fields).
Stateful Functions	Functions can remember state between calls.
Callbacks & Event Handlers	Retain access to outer variables when async code runs later.
Currying & Partial Application	Create reusable, specialized functions.
Module Pattern	Used in JS module design for clean and organized code.
âš ï¸ 5. Disadvantages of Closures (Memory Concern)

Closures can increase memory usage if not managed properly.

Since closures keep references to outer variables,

those variables stay in memory as long as the closure exists,

even if you donâ€™t need them anymore.

function bigData() {
  let largeArray = new Array(1000000).fill("ğŸš€");
  return function() {
    console.log("Using closure");
  };
}

const closureFunc = bigData(); // largeArray still stays in memory!


ğŸ”´ Problem: largeArray is never garbage collected because the closure still references the outer scope.

â™»ï¸ 6. Garbage Collector & Closures

The JavaScript Garbage Collector frees memory that is no longer reachable.

But if a closure still references variables, GC cannot clean them.

Example:

let ref;
function outer() {
  let secret = "hidden data";
  function inner() {
    console.log(secret);
  }
  ref = inner;
}
outer(); // ref now holds closure

ref = null; // âœ… Now closure is unreferenced â†’ GC can clean memory


âœ… Tip: Set unused references to null to help GC clean them up.

ğŸ’¥ 7. Memory Leak via Closures

Memory Leak happens when unused data stays in memory unintentionally.

Example:

function createLeak() {
  let data = new Array(1000000).fill("â—");
  document.getElementById("btn").addEventListener("click", function() {
    console.log(data.length);
  });
}
createLeak();


ğŸ’€ Problem:
Even if you never need data again, the event listener closure keeps it alive in memory.

âœ… Fix:
Remove event listeners when not needed:

element.removeEventListener("click", handler);

ğŸ§  8. Smart Memory Management in Closures

Tips to â€œsmartly collect variablesâ€:

Avoid creating closures inside loops unnecessarily.

Remove event listeners or DOM references when not needed.

Set variables or closures to null when youâ€™re done.

Use WeakMap or WeakSet for storing data that can be garbage-collected automatically.

Example using WeakMap:

const privateData = new WeakMap();

function User(name, age) {
  privateData.set(this, { age });
  this.name = name;
}

User.prototype.getAge = function() {
  return privateData.get(this).age;
};

const user1 = new User("Bhaskar", 21);
console.log(user1.getAge()); // 21


âœ… Here, if user1 is deleted, its private data is automatically garbage-collected.

ğŸ§¾ ğŸ“‹ Summary Table
Concept	Key Idea	Example
Closure	Function remembers outer scope	Counter example
Data Hiding	Private variables	Bank Account example
Constructor + Closure	Private data in objects	Person example
Importance	Reusability, state, encapsulation	Module Pattern
Disadvantage	Memory usage high	Large array captured
Garbage Collector	Frees unreferenced memory	ref = null
Memory Leak	Unreleased closures	Event listener example
Smart Collection	Manage references, WeakMap	WeakMap example