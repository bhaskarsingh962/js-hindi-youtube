JavaScript Execution Flow (Memory + Code)

The code:

var n = 2;

function square(num) {
  var ans = num * num;
  return ans;
}

var square2 = square(n);
var square4 = square(4);

## 1. Memory Creation Phase (Hoisting Phase)

ðŸ‘‰ During this phase:

Variables declared with var are allocated memory and initialized with undefined.

Functions are stored as a whole.

So after scanning code, memory looks like this:

Memory (before execution - Creation Phase)
-------------------------------------------
n        : undefined
square   : function square(num) { var ans = num * num; return ans; }
square2  : undefined
square4  : undefined


âš¡ Notice: Only declarations are stored, not assigned values yet.

## 2. Execution Phase

ðŸ‘‰ Now code runs line by line:

Step 1: var n = 2;
n : 2
square   : function {...}
square2  : undefined
square4  : undefined

## Step 2: Function declaration (already in memory)

Nothing changes here.

## Step 3: var square2 = square(n);

Call square(2)

A new Execution Context is created for square.

Inside function:

num = 2
ans = num * num = 4


Return 4.

Update memory:

n : 2
square   : function {...}
square2  : 4
square4  : undefined

## Step 4: var square4 = square(4);

Call square(4)

New Execution Context again.

Inside function:

num = 4
ans = 16


Return 16.

Update memory:

n : 2
square   : function {...}
square2  : 4
square4  : 16

## 3. ASCII Diagram of Execution
ðŸ”¹ Global Execution Context
 -------------------------
|     Memory (Heap)       |
|-------------------------|
| n        : 2            |
| square   : [Function]   |
| square2  : 4            |
| square4  : 16           |
 -------------------------
|     Call Stack          |
|-------------------------|
| Global()                |
 -------------------------

ðŸ”¹ When square(n) is called:
 -------------------------
|     Memory              |
|-------------------------|
| num : 2                 |
| ans : 4                 |
 -------------------------
|     Call Stack          |
|-------------------------|
| square()                |
| Global()                |
 -------------------------


After returning, square() context is destroyed â†’ back to Global.

ðŸ”‘ Interview Points to Say

## First phase (Memory Creation): All variables â†’ undefined, functions â†’ full definition.

## Second phase (Execution): Code runs line by line, assignments happen.

Functions create new execution contexts when invoked.

## Call Stack manages these contexts (LIFO order).

## After function execution â†’ its context is removed from the stack.

## call stack is also known as a 
execution context stack
program stack
control stack
runtime stack
machine stack